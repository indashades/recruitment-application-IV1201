#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");
const { spawnSync } = require("child_process");
const { Client } = require("pg");

const { hashPassword } = require(path.join(__dirname, "..", "src", "utils", "password"));

const DATABASE_URL = process.env.DATABASE_URL;
if (!DATABASE_URL) {
  console.error("Missing DATABASE_URL environment variable.");
  process.exit(1);
}

const ROOT = path.join(__dirname, "..");
const MIGRATION_DIR = path.join(ROOT, "migration");

const LEGACY_DUMP = path.join(MIGRATION_DIR, "existing-database.sql");
const GENERATED_LEGACY = path.join(MIGRATION_DIR, "_generated_existing_to_legacy.sql");
const NEW_SCHEMA = path.join(MIGRATION_DIR, "01_new_schema.sql");
const COPY_SQL = path.join(MIGRATION_DIR, "02_copy_legacy_to_new.sql");

function requireFile(filePath) {
  if (!fs.existsSync(filePath)) {
    console.error(`Missing file: ${filePath}`);
    process.exit(1);
  }
}

function runPsql(label, args) {
  console.log(`==> ${label}`);
  const r = spawnSync(
    "psql",
    ["--set", "ON_ERROR_STOP=1", "-d", DATABASE_URL, ...args],
    {
      stdio: "inherit",
      env: { ...process.env, PGSSLMODE: "require" },
    }
  );

  if (r.error) {
    console.error(`Failed to execute psql: ${r.error.message}`);
    process.exit(1);
  }
  if (r.status !== 0) {
    process.exit(r.status || 1);
  }
}

function runSql(label, sql) {
  runPsql(label, ["-c", sql]);
}

function runFile(label, filePath, preSql = []) {
  requireFile(filePath);
  const args = [];
  for (const stmt of preSql) {
    args.push("-c", stmt);
  }
  args.push("-f", filePath);
  runPsql(label, args);
}

function stripNeonIncompatibleSql(sql) {
  return sql
    .split(/\r?\n/)
    .filter((line) => {
      const l = line.trim();

      if (/^\\connect\b/i.test(l)) return false;

      if (/^ALTER\s+.*\s+OWNER\s+TO\s+/i.test(l)) return false;
      if (/^SET\s+SESSION\s+AUTHORIZATION\s+/i.test(l)) return false;
      if (/^CREATE\s+ROLE\s+/i.test(l)) return false;
      if (/^ALTER\s+ROLE\s+/i.test(l)) return false;
      if (/^(GRANT|REVOKE)\s+/i.test(l)) return false;
      if (/^ALTER\s+DEFAULT\s+PRIVILEGES\s+/i.test(l)) return false;

      if (/^ALTER\s+DATABASE\s+/i.test(l)) return false;

      if (/^SET\s+search_path\s*=/i.test(l)) return false;
      if (/set_config\('search_path'/i.test(l)) return false;

      return true;
    })
    .join("\n");
}

function generateLegacySql() {
  requireFile(LEGACY_DUMP);

  const raw = fs.readFileSync(LEGACY_DUMP, "utf8");

  const rewrittenBody = raw.replace(/\bpublic\./g, "legacy.");
  const cleaned = stripNeonIncompatibleSql(rewrittenBody);

  const finalSql = [
    "-- AUTO-GENERATED by db-init-cloud.js",
    "CREATE SCHEMA IF NOT EXISTS legacy;",
    "",
    cleaned,
    "",
  ].join("\n");

  fs.writeFileSync(GENERATED_LEGACY, finalSql, "utf8");
  console.log(`Generated: ${GENERATED_LEGACY}`);
}

async function syncImportedAccounts() {
  console.log("==> Sync imported account roles + password state");
  const client = new Client({
    connectionString: DATABASE_URL,
    ssl: { rejectUnauthorized: false },
  });

  await client.connect();

  try {
    const reg = await client.query(`
      SELECT
        to_regclass('legacy.person')       AS legacy_person,
        to_regclass('legacy.role')         AS legacy_role,
        to_regclass('public.user_account') AS user_account
    `);

    const row = reg.rows[0] || {};
    if (!row.legacy_person || !row.legacy_role || !row.user_account) {
      console.log("Skipping imported account sync (required tables not present).");
      return;
    }

    const q = await client.query(`
      SELECT
        p.person_id,
        p.username,
        p.password,
        CASE
          WHEN LOWER(BTRIM(r.name)) = 'recruiter' THEN 'recruiter'
          WHEN LOWER(BTRIM(r.name)) = 'applicant' THEN 'applicant'
          WHEN p.role_id = 1 THEN 'recruiter'
          WHEN p.role_id = 2 THEN 'applicant'
          ELSE NULL
        END AS mapped_role
      FROM legacy.person p
      LEFT JOIN legacy.role r ON r.role_id = p.role_id
      WHERE NULLIF(BTRIM(p.username), '') IS NOT NULL
      ORDER BY p.person_id ASC
    `);

    if (q.rows.length === 0) {
      console.log("No imported account rows with username found.");
      return;
    }

    let hashed = 0;
    let resetRequired = 0;

    for (const r of q.rows) {
      if (!r.mapped_role) {
        throw new Error(`Unknown legacy role for person_id=${r.person_id}`);
      }

      if (r.password && r.password.trim() !== "") {
        const pwHash = await hashPassword(r.password);
        await client.query(
          `UPDATE public.user_account
             SET password_hash = $1,
                 role = $2,
                 needs_password_reset = FALSE
           WHERE person_id = $3`,
          [pwHash, r.mapped_role, r.person_id]
        );
        hashed += 1;
      } else {
        await client.query(
          `UPDATE public.user_account
             SET password_hash = NULL,
                 role = $1,
                 needs_password_reset = TRUE
           WHERE person_id = $2`,
          [r.mapped_role, r.person_id]
        );
        resetRequired += 1;
      }
    }

    console.log(`Imported accounts updated: ${q.rows.length} (hashed=${hashed}, reset_required=${resetRequired})`);
  } finally {
    await client.end();
  }
}

async function main() {
  requireFile(LEGACY_DUMP);
  requireFile(NEW_SCHEMA);
  requireFile(COPY_SQL);

  console.log("==> Generate legacy SQL");
  generateLegacySql();

  runSql(
    "Reset legacy schema",
    "DROP SCHEMA IF EXISTS legacy CASCADE; CREATE SCHEMA legacy;"
  );

  runSql("Ensure public schema exists", "CREATE SCHEMA IF NOT EXISTS public;");

  runFile(
    "Load legacy dump into legacy.*",
    GENERATED_LEGACY,
    ["SET search_path TO legacy, pg_catalog;"]
  );

  runFile(
    "Create new schema in public.*",
    NEW_SCHEMA,
    ["SET search_path TO public, pg_catalog;"]
  );

  runFile(
    "Copy legacy data into new schema",
    COPY_SQL,
    ["SET search_path TO public, legacy, pg_catalog;"]
  );

  await syncImportedAccounts();

  runSql(
    "Verify row counts",
    `
    SELECT 'legacy.person' AS table, COUNT(*)::bigint AS count FROM legacy.person
    UNION ALL
    SELECT 'public.person', COUNT(*)::bigint FROM public.person
    UNION ALL
    SELECT 'public.user_account', COUNT(*)::bigint FROM public.user_account
    UNION ALL
    SELECT 'public.application', COUNT(*)::bigint FROM public.application
    UNION ALL
    SELECT 'public.competence', COUNT(*)::bigint FROM public.competence;
    `
  );

  console.log("\nCloud DB init complete.");
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
